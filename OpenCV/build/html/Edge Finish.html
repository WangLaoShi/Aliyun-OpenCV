

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>处理边缘 &mdash; OpenCV 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="prev" title="图像滤波" href="Image Filtering.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> OpenCV
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="OpenCV Common Operation.html">OpenCV常用操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basic Image Operation.html">对图像的基本操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Common methods of Image Processing.html">处理图像的常用方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Image Filtering.html">图像滤波</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">处理边缘</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#">卷积边界问题及其处理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#">边界问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#">处理</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sobel">Sobel算子</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#">卷积的应用：图像边缘提取</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sobel">Sobel算子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sobelapi">Sobel算子API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#laplacian">Laplacian算子</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cv-laplacian">cv::Laplacian</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#canny">Canny算法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#">算法流程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">高低阈值的选取</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cv-canny">cv::Canny</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">OpenCV</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>处理边缘</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Edge Finish.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="">
<span id="id1"></span><h1>处理边缘<a class="headerlink" href="#" title="永久链接至标题">¶</a></h1>
<div class="section" id="">
<span id="id2"></span><h2>卷积边界问题及其处理<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<div class="section" id="">
<span id="id3"></span><h3>边界问题<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/1.png?raw=true" /></p>
<p><strong>卷积边界问题</strong>是指的图像卷积的时候边界像素，不能被卷积操作，原因在于边界像素没有完全跟kernel重叠，所以当3x3滤波时候有1个像素（最上面一行的像素）的边缘没有被处理，5x5滤波的时候有2个像素的边缘没有被处理。</p>
</div>
<div class="section" id="">
<span id="id4"></span><h3>处理<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>在卷积开始之前增加边缘像素，填充的像素值为0或者RGB黑色，比如3x3在四周各填充1个像素的边缘，这样就确保图像的边缘被处理，在卷积处理之后再去掉这些边缘。openCV中默认的处理方法是： <code class="docutils literal notranslate"><span class="pre">BORDER_DEFAULT</span></code>，此外常用的还有如下几种：</p>
<ul class="simple">
<li><strong>BORDER_CONSTANT：用指定像素填充边缘</strong></li>
<li><strong>BORDER_REPLICATE：用已知边缘像素值来填充边缘像素值</strong></li>
<li><strong>BORDER_WRAP：用另外一边的像素来补偿填充</strong></li>
</ul>
<p>下面是给图像自定义添加边缘</p>
<p><strong>copyMakeBorder：给图像添加边缘API</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>copyMakeBorder（
  Mat src, // 输入图像
  Mat dst, // 添加边缘图像
  int top, // 边缘长度，一般上下左右都取相同值，
  int bottom,
  int left,
  int right, 
  int borderType // 边缘类型
  Scalar value // Scalar用于指定颜色,边缘类型为 BORDER_CONSTANT 时，有效
）
</pre></div>
</div>
<p>下面代码展示一下如何具体使用：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>

<span class="n">Scalar</span> <span class="n">color</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span>
<span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">OUTPUT_WIN</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
</pre></div>
</div>
<p>这是完整演示四种方法如何切换的代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>

<span class="n">Mat</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">kernal</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">&quot;D:/1.jpg&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;could not load image...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">INPUT_WIN</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;input image&quot;</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">OUTPUT_WIN</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;result image&quot;</span><span class="p">;</span>
    <span class="n">namedWindow</span><span class="p">(</span><span class="n">INPUT_WIN</span><span class="p">,</span> <span class="n">CV_WINDOW_AUTOSIZE</span><span class="p">);</span>
    <span class="n">namedWindow</span><span class="p">(</span><span class="n">OUTPUT_WIN</span><span class="p">,</span> <span class="n">CV_WINDOW_AUTOSIZE</span><span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;input image&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>

    <span class="n">RNG</span> <span class="n">rng</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span> <span class="c1">//生成随机数</span>
    <span class="kt">int</span> <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_DEFAULT</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">waitKey</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">c</span> <span class="o">==</span><span class="mi">27</span> <span class="p">)</span> <span class="c1">//按下键盘ESC对应的数值就是27，也就是按下键盘推出while循环</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_REPLICATE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_WRAP</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;c&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_CONSTANT</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;d&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_DEFAULT</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Scalar</span> <span class="n">color</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span> <span class="c1">//生成0-255之前随机颜色值</span>
        <span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
        <span class="n">imshow</span><span class="p">(</span><span class="n">OUTPUT_WIN</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sobel">
<span id="sobel"></span><h2>Sobel算子<a class="headerlink" href="#sobel" title="永久链接至标题">¶</a></h2>
<div class="section" id="">
<span id="id5"></span><h3>卷积的应用：图像边缘提取<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>边缘是图像像素发生显著跃迁的地方，通过求一阶导数可以很好地捕捉边缘。</p>
<p>delta =  f(x) – f(x-1), delta越大，说明像素在X方向变化越大，边缘信号越强。</p>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/2.png?raw=true" /></p>
<p><center>图中从头发到脸这一段像素发生了显著的变化</center></p>
</div>
<div class="section" id="sobel">
<span id="id6"></span><h3>Sobel算子<a class="headerlink" href="#sobel" title="永久链接至标题">¶</a></h3>
<p>Sobel算子又被称为一阶微分算子，求导算子，在水平和垂直两个方向上求导，得到图像X方法与Y方向梯度图像。它是离散微分算子（discrete differentiation operator），用来计算<strong>灰度图像</strong>的近似梯度。</p>
<p>Soble算子功能集合高斯平滑和微分求导。</p>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/3.png?raw=true" />
<center>水平梯度和垂直梯度</center></p>
<p>我们以水平梯度为例。他的水平方向上面变化十分的明显，在水平方向上给不同的权重，通过权重值来扩大差异。</p>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/4.png?raw=true" /></p>
<p>最终图像梯度如上图所示，一般为了让计算机算的更快一些，我们会取绝对值的形式。</p>
</div>
<div class="section" id="sobelapi">
<span id="sobelapi"></span><h3>Sobel算子API<a class="headerlink" href="#sobelapi" title="永久链接至标题">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>cv::Sobel (
InputArray Src // 输入图像
OutputArray dst// 输出图像，大小与输入图像一致
int depth // 输出图像深度. 
Int dx.  // X方向，几阶导数，如果想求x方向的时候就让这个数取1，y方向上取0
int dy // Y方向，几阶导数. 
int ksize, SOBEL算子kernel大小，必须是1、3、5、7、
double scale  = 1
double delta = 0
int borderType = BORDER_DEFAULT
)
</pre></div>
</div>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/5.png?raw=true" /></p>
<p>这里关于深度说一下，因为考虑两个图像像素之间的差值，可能做差之后超过255，超过255的8U灰度图像就会被截断，所以相比于输入，输出会上升一个层次。（-1就是表示选择和原先的一样）</p>
<p><strong>Sobel算子改进版：Scharr</strong></p>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/6.png?raw=true" /></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cv</span><span class="o">::</span><span class="n">Scharr</span> <span class="p">(</span>
<span class="n">InputArray</span> <span class="n">Src</span> <span class="c1">// 输入图像</span>
<span class="n">OutputArray</span> <span class="n">dst</span><span class="c1">// 输出图像，大小与输入图像一致</span>
<span class="kt">int</span> <span class="n">depth</span> <span class="c1">// 输出图像深度. </span>
<span class="n">Int</span> <span class="n">dx</span><span class="p">.</span>  <span class="c1">// X方向，几阶导数</span>
<span class="kt">int</span> <span class="n">dy</span> <span class="c1">// Y方向，几阶导数. </span>
<span class="kt">double</span> <span class="n">scale</span>  <span class="o">=</span> <span class="mi">1</span>
<span class="kt">double</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kt">int</span> <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_DEFAULT</span>
<span class="p">)</span>
</pre></div>
</div>
<p>处理流程：</p>
<ul class="simple">
<li><strong>GaussianBlur( src, dst, Size(3,3), 0, 0, BORDER_DEFAULT );</strong></li>
<li><strong>cvtColor( src,  gray, COLOR_RGB2GRAY );</strong></li>
<li><strong>addWeighted( A, 0.5,B, 0.5, 0, AB);</strong></li>
<li><strong>convertScaleAbs(A, B)// 计算图像A的像素绝对值，输出到图像B</strong></li>
</ul>
<p>Sobel实现代码如下，Scharr代码一样。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>

<span class="n">Mat</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">&quot;D:/1.jpg&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;could not load image...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;input image&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

    <span class="n">GaussianBlur</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Size</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">Mat</span> <span class="n">gray_src</span><span class="p">;</span>
    <span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">gray_src</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;gray image&quot;</span><span class="p">,</span> <span class="n">gray_src</span><span class="p">);</span>

    <span class="n">Mat</span> <span class="n">xgrad</span><span class="p">,</span> <span class="n">ygrad</span><span class="p">;</span>
    <span class="n">Sobel</span><span class="p">(</span><span class="n">gray_src</span><span class="p">,</span> <span class="n">xgrad</span><span class="p">,</span> <span class="n">CV_16S</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="c1">//我们这里对于CV_8U的输入图像，向上取一个数量级，使得不会发生超过255被截断的事情发生</span>
    <span class="n">Sobel</span><span class="p">(</span><span class="n">gray_src</span><span class="p">,</span> <span class="n">ygrad</span><span class="p">,</span> <span class="n">CV_16S</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> 
    <span class="n">convertScaleAbs</span><span class="p">(</span><span class="n">xgrad</span><span class="p">,</span> <span class="n">xgrad</span><span class="p">);</span>  <span class="c1">//计算的时候也可能出现负数，负数的话因为不是0-255之间，会被强制变成0，这不是我们想要的，我们这样强制把他们变成正的</span>
    <span class="n">convertScaleAbs</span><span class="p">(</span><span class="n">ygrad</span><span class="p">,</span> <span class="n">ygrad</span><span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;xgrad&quot;</span><span class="p">,</span> <span class="n">xgrad</span><span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;ygrad&quot;</span><span class="p">,</span> <span class="n">ygrad</span><span class="p">);</span>



    <span class="n">Mat</span> <span class="n">xygrad</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="n">xgrad</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">xgrad</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="cm">/* 注释的代码是不使用函数求xgrad和ygrad的合起来的值 */</span>
    <span class="c1">//int width = xgrad.cols;</span>
    <span class="c1">//int height = ygrad.rows;</span>
    <span class="c1">//for (int row = 0; row &lt; height; row++)</span>
    <span class="c1">//{</span>
    <span class="c1">//  for (int col = 0; col &lt; width; col++)</span>
    <span class="c1">//  {</span>
    <span class="c1">//      int xg = xgrad.at&lt;uchar&gt;(row, col);</span>
    <span class="c1">//      int yg = ygrad.at&lt;uchar&gt;(row, col);</span>
    <span class="c1">//      int xy = xg + yg;</span>
    <span class="c1">//      xygrad.at&lt;uchar&gt;(row, col) = saturate_cast&lt;uchar&gt;(xy);</span>
    <span class="c1">//  }</span>
    <span class="c1">//}</span>
    <span class="n">addWeighted</span><span class="p">(</span><span class="n">xgrad</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ygrad</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xygrad</span><span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Final result&quot;</span><span class="p">,</span> <span class="n">xygrad</span><span class="p">);</span>
    <span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="laplacian">
<span id="laplacian"></span><h2>Laplacian算子<a class="headerlink" href="#laplacian" title="永久链接至标题">¶</a></h2>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/7.png?raw=true" /></p>
<p>在二阶导数的时候，最大变化处的值为零即边缘是零值。通过二阶导数计算，依据此理论我们可以计算图像二阶导数，提取边缘。</p>
<div class="section" id="cv-laplacian">
<span id="cv-laplacian"></span><h3>cv::Laplacian<a class="headerlink" href="#cv-laplacian" title="永久链接至标题">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Laplacian</span><span class="p">(</span>
<span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span>
<span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span>
<span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="c1">//深度CV_16S</span>
<span class="kt">int</span> <span class="n">kisze</span><span class="p">,</span> <span class="c1">// 3</span>
<span class="kt">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="kt">double</span> <span class="n">delta</span> <span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
<span class="kt">int</span> <span class="n">borderType</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">)</span>
</pre></div>
</div>
<p>处理流程是</p>
<ul class="simple">
<li><strong>高斯模糊 – 去噪声GaussianBlur()</strong></li>
<li><strong>转换为灰度图像cvtColor()</strong></li>
<li><strong>拉普拉斯 – 二阶导数计算Laplacian()</strong></li>
<li><strong>取绝对值convertScaleAbs()</strong></li>
<li><strong>显示结果</strong></li>
</ul>
<p>这里再说一下取绝对值的意义，不管算的值是负的还是正的，都代表是的图像之间的差异，不能因为是负的数就直接删掉不管了。所以我们需要取绝对值来保留这份差异。</p>
<p>具体图像处理代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>

<span class="n">Mat</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">&quot;D:/1.jpg&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;could not load image...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">namedWindow</span><span class="p">(</span><span class="s">&quot;input image&quot;</span><span class="p">,</span> <span class="n">CV_WINDOW_AUTOSIZE</span><span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;input image&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

    <span class="n">Mat</span> <span class="n">gray_src</span><span class="p">,</span> <span class="n">edge_image</span><span class="p">;</span>
    <span class="n">GaussianBlur</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Size</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">cvtColor</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">gray_src</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span>

    <span class="n">Laplacian</span><span class="p">(</span><span class="n">gray_src</span><span class="p">,</span> <span class="n">edge_image</span><span class="p">,</span> <span class="n">CV_16S</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">convertScaleAbs</span><span class="p">(</span><span class="n">edge_image</span><span class="p">,</span> <span class="n">edge_image</span><span class="p">);</span>
    <span class="n">threshold</span><span class="p">(</span><span class="n">edge_image</span><span class="p">,</span> <span class="n">edge_image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">THRESH_OTSU</span> <span class="o">|</span> <span class="n">THRESH_BINARY</span><span class="p">);</span> <span class="c1">//用Otsu算法获取最优二值化的值进行图像二值化处理</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;output image&quot;</span><span class="p">,</span> <span class="n">edge_image</span><span class="p">);</span>

    <span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="canny">
<span id="canny"></span><h2>Canny算法<a class="headerlink" href="#canny" title="永久链接至标题">¶</a></h2>
<p>Canny是边缘检测算法，在1986年提出的。是一个十分常用和实用的边缘检测算法。</p>
<div class="section" id="">
<span id="id7"></span><h3>算法流程<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>算法大致流程：</p>
<ul class="simple">
<li><strong>高斯模糊 - GaussianBlur</strong></li>
<li><strong>灰度转换 - cvtColor</strong></li>
<li><strong>计算梯度 – Sobel/Scharr</strong></li>
<li><strong>非最大信号抑制</strong></li>
<li><strong>高低阈值输出二值图像</strong></li>
</ul>
<p>这里说一下高斯模糊的作用，高斯模糊的主要作用就是降噪。防止异常值影响最终结果。</p>
<p><strong>非最大信号抑制</strong>是关于边缘我们只能有一个像素一个值，关于非最大值要进行一定抑制，来突出最大边缘。非最大信号抑制具体来说就是对于该方向上的点，如果不是最大信号，我们就把它去掉。</p>
<p><strong>高低阈值连接</strong>是非最大信号抑制之后的图像都是一些像素点，需要把他们连接成线。这里如果大于最高阈值的像素，我们都要把他们保留下来，小于最大阈值的全部舍弃。然后介于最大阈值和最小阈值之间的我们会对其进行一个阈值连接。边缘连接之后就得到一个二值图像然后把他们输出。</p>
<p>大概这是完整的使用canny算法的流程。</p>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/8.png?raw=true" /></p>
<p>如图所示图片中的左侧是Sobel算子，$\theta$表示的是梯度的变化情况，看哪个方向上梯度变化更大，以此来确定角度。右图所示的就是角度区间。在每一个扇区，我们会对当前的像素和上下两个像素进行比较，如果当前的像素小于上下两个像素，那么上下两个像素保留，当前的像素舍弃，如果当前像素大于上下两个像素，那么上下两个像素被舍弃，当前像素保留。（我们只在每个扇区选择与他相近的两个像素）</p>
<div class="section" id="">
<span id="id8"></span><h4>高低阈值的选取<a class="headerlink" href="#" title="永久链接至标题">¶</a></h4>
<p>什么样的阈值是好的阈值，高低阈值到底该怎么选取呢？在实际编程中T1，T2为阈值，凡是高于T2的都保留，凡是小于T1都丢弃，从高于T2的像素出发，凡是大于T1而且相互连接的，都保留。最终得到一个输出二值图像。</p>
<p>推荐的高低阈值比值为 T2: T1 = 3:1/2:1 其中T2为高阈值，T1为低阈值。</p>
</div>
</div>
<div class="section" id="cv-canny">
<span id="cv-canny"></span><h3>cv::Canny<a class="headerlink" href="#cv-canny" title="永久链接至标题">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>Canny（
InputArray src, // 8-bit的输入图像，不支持彩色图像，一定要提前转为灰度
OutputArray edges,// 输出边缘图像， 一般都是二值图像，背景是黑色
double threshold1,// 低阈值，常取高阈值的1/2或者1/3
double threshold2,// 高阈值
int aptertureSize,// Soble算子的size，通常3x3，取值3
bool L2gradient // 选择 true表示是L2来归一化，否则用L1归一化（L2是二范数，L1是一范数）
）
</pre></div>
</div>
<p>关于归一化，一般情况下为了计算速度，通常选择L1归一化。所以参数设置为false。</p>
<p>完整代码实现如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>

<span class="n">Mat</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">gray_src</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">t1_value</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max_value</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Canny_Demo</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">&quot;D:/1.jpg&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;could not load image...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">namedWindow</span><span class="p">(</span><span class="s">&quot;input image&quot;</span><span class="p">,</span> <span class="n">CV_WINDOW_AUTOSIZE</span><span class="p">);</span>
    <span class="n">namedWindow</span><span class="p">(</span><span class="s">&quot;output image&quot;</span><span class="p">,</span> <span class="n">CV_WINDOW_AUTOSIZE</span><span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;input image&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

    <span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">gray_src</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span>
    <span class="n">createTrackbar</span><span class="p">(</span><span class="s">&quot;Threshold Value:&quot;</span><span class="p">,</span> <span class="s">&quot;output image&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t1_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">,</span> <span class="n">Canny_Demo</span><span class="p">);</span>  <span class="c1">//创建一个拖动条，触发拖动条的回调函数为Canny_Demo</span>
    <span class="n">Canny_Demo</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Canny_Demo</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Mat</span> <span class="n">edge_output</span><span class="p">;</span>
    <span class="n">blur</span><span class="p">(</span><span class="n">gray_src</span><span class="p">,</span> <span class="n">gray_src</span><span class="p">,</span> <span class="n">Size</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">BORDER_DEFAULT</span><span class="p">);</span>
    <span class="n">Canny</span><span class="p">(</span><span class="n">gray_src</span><span class="p">,</span> <span class="n">edge_output</span><span class="p">,</span> <span class="n">t1_value</span><span class="p">,</span> <span class="n">t1_value</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="cm">/* 注释掉部分是用彩色图像显示canny算子，如果不加的话就是用黑白像素来显示canny算子处理结果，如果用彩色像素的话，处理速度会更慢一些</span>
<span class="cm">    dst.create(src.size(), src.type);</span>
<span class="cm">    src.copyTo(dst, edge_output);</span>
<span class="cm">    imshow(&quot;output image&quot;, dst);</span>
<span class="cm">    */</span>
    
    <span class="n">imshow</span><span class="p">(</span><span class="s">&quot;output image&quot;</span><span class="p">,</span> <span class="n">edge_output</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样处理的图片最后是黑底，白色的边：</p>
<p><img alt="image" src="https://github.com/Einstellung/OpenCV_learning/blob/master/OpenCV/images/Edge%20Finish/9.png?raw=true" /></p>
<p>如果翻转过来，改成白边黑底可能看起来效果会更好，我们只需要更改这个操作</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;output image&quot;</span><span class="p">,</span> <span class="o">~</span><span class="n">edge_output</span><span class="p">);</span>  <span class="c1">//~表示取反，像素取反就可以变成白底黑边了</span>
</pre></div>
</div>
<p>最后说一下，影响Canny算法的主要成像因素是低阈值和高阈值之间的选择。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="Image Filtering.html" class="btn btn-neutral" title="图像滤波" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Hunag Xinyuan

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>